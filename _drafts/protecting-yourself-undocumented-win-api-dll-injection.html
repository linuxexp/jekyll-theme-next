---
layout: post
title: 'Protecting Yourself: undocumented win API, dll injection.'
date: 
type: post
parent_id: '0'
published: false
password: ''
status: draft
categories: []
tags: []
meta:
  blogger_blog: experi-blog-n.blogspot.com
  blogger_permalink: "/2011/06/undocumented-win-apis-and-basic-dll.html"
  blogger_author: linux1
  _edit_last: '26412816'
  original_post_id: '62'
  _wp_old_slug: '62'
author:
  login: linuxexperi
  email: linux1@zoho.com
  display_name: Raja Jamwal
  first_name: ''
  last_name: ''
---
<div style="text-align:left;" dir="ltr">Well, There are many guys out there who wanna know windows undocumented api. There had been a court case on Microsoft in past for Microsoft Office by some other office application making software company(I think lotus(apple)) for that It uses some undocumented windows api. So you may be by now very excited to know, what those great calls may be. I found a site on web that documents undocumented windows API, I mean NT Kernel APIs, here's the link <a href="http://undocumented.ntinternals.net/">http://undocumented.ntinternals.net/</a>. But wait, what you gonna get? According to it, it documents NT Kernel.<!--more--><br />But believe me, if you use that. You will be in deep SHIT!. How, read on. I haven't explored that site alot but what I can see is that. I just documents the NT(new technology) kernel internal calls,well if you don't trust me, and I like you not to trust me or anyone, whatever I or anyone says until you can't satisfy you mind. I want you to download a very useful application, dllexport from here, <a href="http://www.nirsoft.net/utils/dll_export_viewer.html">http://www.nirsoft.net/utils/dll_export_viewer.html</a>what all this application does is, basically it allows you to view anything that is exported in a DLL file(Dynamic link library). A dll is basically a file, a binary file indeed. which actually does nothing, means it can't execute, all it's about, is it holds procedure and function and other program calls them loads them and then use the function declared in them. Wait? You may be thinking, I said the programs loads the dll, but when I code in win32, CC++. I don't actually load any dll, I just includes that windows.h, iostream.h, stdio.h include file, #include ,#include ,#include right. okay. let me ask you one thing, what you need to call a function or procedure. A function prototype and ofcourse the function code itself. Actually what happens is that, there are some standard dlls (i.e user32.dll, kernel32.dll.....) or runtime dlls ( MS VC++ runtime downloads are just about that ), that windows image loader loads with every executable file, means that function code is already loaded in executable file memory. Now you need function prototype to access those functions, isn't it and that what windows.h and any other includable file does. it contains prototypes. Now back on undocumented NT Kernel calls, The dll that holds the kernel calls is ntdll located in ntdll.dll file in %systemroot%system32ntdll.dll , where %systemroot% is the window directory, like c:windows.
<p>Actually the answer to problem is hidden in, how windows work at core. Every process or application should use win32 api calls either directly or by any other language's framework. Win32 api implementaion, means win32 procedure then calls NT Kernal procedure, and then NT Kernel takes over and does the work. see my post on "Behind the scene story of opening a file" related to it, here <span style="text-decoration:line-through;"><a href="http://cyberlifeday.blogspot.com/2009/12/behind-scence-story-of-opening-file.html">http://cyberlifeday.blogspot.com/2009/12/behind-scence-story-of-opening-file.html</a>.</span> So why Microsoft follows the long way, because for the sake of compatibility between different OS version. Look at it this way, you use the NT kernel call, it works great or may be fast. Now there comes another OS from Microsoft and you are excited to check out your application on that system and you executed you app, just to see that your application crashes in that big blue screen of death. Now what happened? may be, you be using a very critical NT kernel call. and Microsoft simply changed or updated that kernel call in next OS. Even if your application doesn't crashes like that, your application will be simply be accumulating crashes, errors and faults over new new updation to OS and this way it'll become very pain taking to DEBUG such an application. So, it's you that brought the death to your application. So the conclusion is, even if Microsoft used something like that in office application, let it be with Microsoft, and use Win32 or official documented stuff, if you don't want to take risk, But for experimenting that would be interesting. There is no way, no mean that Microsoft will ever officially document that, now or in future.</p>
<p>Now let's move on Hijacking or Hacking the complete windows workstation, I really mean, what I say. No Fun! No Trick! Just Real, Behind The Scenes. Lets start. Well Remember, I told you about user32.dll. Well in short, if you see a application thats having to do anything with windows dialog, menus, bitmaps etc....you are seeing a application that is using user32.dll indeed!. Before moving on, here's something more. Every DLL has a entry point called DllMain like main in cc++ or WinMain inWin32 API, though these can be easily changed. When a dll is loaded, this DllMain is called, with a reason like to connect or disconnect, passed to it as a double word (DWORD) parameter. Here's the DllMain function prototype</p>
<pre class="libCScode" style="white-space:pre-wrap;"><code><span id="ctl00_MTCS_main_ctl03">BOOL WINAPI DllMain( HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved );</span></code><span id="ctl00_MTCS_main_ctl03"> </span></pre>
<pre class="libCScode" style="font-family:inherit;white-space:pre-wrap;"><span id="ctl00_MTCS_main_ctl03">Now the reason could be anything with value, 0 (DLL_PROCESS_DETACH), 1 (DLL_PROCESS_ATTACH), 2 (DLL_THREAD_ATTACH), 3 (DLL_THREAD_DETACH). I hope the names are self explanatory.</span></pre>
<pre class="libCScode" style="font-family:inherit;white-space:pre-wrap;"><span id="ctl00_MTCS_main_ctl03">So here's the interesting thing. The DllMain of user32.dll is called when a windowsy application loads. What it does in DLL_PROCESS_ATTACH notification, is that it enumerates and loads dlls stated in AppInit_DLLs value in following registry key</span></pre>
<pre class="libCScode" style="white-space:pre-wrap;"><span id="ctl00_MTCS_main_ctl03"> </span></pre>
<pre class="libCScode" style="white-space:pre-wrap;"><span id="ctl00_MTCS_main_ctl03">HKEY_LOCAL_MACHINESoftwareMicrosoftWindows NTCurrentVersionWindows </span></pre>
<pre class="libCScode" style="white-space:pre-wrap;"><span id="ctl00_MTCS_main_ctl03"> </span></pre>
<pre class="libCScode" style="font-family:inherit;white-space:pre-wrap;"><span id="ctl00_MTCS_main_ctl03">One more thing before going on further, In windows, your application or process can use or manipulate only that thing that belongs to it, means is in its address space. All that basically means, you can't go and manipulate other application code with your application. For more on this, read <span style="text-decoration:line-through;"><a href="http://cyberlifeday.blogspot.com/2009/12/behind-scence-story-of-opening-file.html">"Behind The Scene Story Of Opening a File"</a> </span>. Now back on road, we can make a dll that have some code that we desire and loads it in the above key. Now with that, in our dll's DLL_PROCESS_ATTACH, we can code what the application, that loaded the user32.dll will do. This is the way that is used in those password showing app, password and other confidential data recording application. Now the application is just under your full control, the possibilities are endless, you can bring a havoc. This way of loading your code in other process's address space is called DLL Injection. Well this's it for this post, hopefully I'll write on creating DLLs in coming posts. </span></pre>
</div>
<div class="blogger-post-footer"><img src="{{ site.baseurl }}/assets/3794580430282154847-785231680996945238?l=experi-blog-n.blogspot.com" alt="" height="1" /></div>
